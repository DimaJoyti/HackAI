package cybersecurity

import (
	"context"
	"fmt"
	"strings"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"

	"github.com/dimajoyti/hackai/pkg/llm/providers"
	"github.com/dimajoyti/hackai/pkg/llm/retrieval"
	"github.com/dimajoyti/hackai/pkg/logger"
)

var vulnScannerTracer = otel.Tracer("hackai/agents/cybersecurity/vulnerability_scanner")

// VulnerabilityScanner implements AI-powered vulnerability scanning
type VulnerabilityScanner struct {
	provider  providers.LLMProvider
	retriever *retrieval.HybridRetriever
	logger    *logger.Logger
	vulnDB    VulnerabilityDatabase
}

// VulnerabilityScanRequest represents a vulnerability scan request
type VulnerabilityScanRequest struct {
	Target  string `json:"target"`
	Content string `json:"content"`
	Type    string `json:"type"`
}

// VulnerabilityDatabase contains vulnerability knowledge
type VulnerabilityDatabase struct {
	CVEDatabase   map[string]CVEEntry     `json:"cve_database"`
	OWASPTop10    []OWASPVulnerability    `json:"owasp_top10"`
	AIVulns       []AIVulnerability       `json:"ai_vulnerabilities"`
	ScanTemplates map[string]ScanTemplate `json:"scan_templates"`
}

// CVEEntry represents a CVE database entry
type CVEEntry struct {
	ID          string    `json:"id"`
	Description string    `json:"description"`
	CVSS        float64   `json:"cvss"`
	Severity    string    `json:"severity"`
	Published   time.Time `json:"published"`
	Modified    time.Time `json:"modified"`
	References  []string  `json:"references"`
	CWE         []string  `json:"cwe"`
}

// OWASPVulnerability represents OWASP Top 10 vulnerability
type OWASPVulnerability struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Impact      string   `json:"impact"`
	Prevention  []string `json:"prevention"`
	Examples    []string `json:"examples"`
}

// AIVulnerability represents AI-specific vulnerability
type AIVulnerability struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Category    string   `json:"category"`
	Description string   `json:"description"`
	Impact      string   `json:"impact"`
	Mitigation  []string `json:"mitigation"`
	Detection   []string `json:"detection"`
}

// ScanTemplate represents a vulnerability scan template
type ScanTemplate struct {
	Name        string   `json:"name"`
	Type        string   `json:"type"`
	Checks      []string `json:"checks"`
	Patterns    []string `json:"patterns"`
	Severity    string   `json:"severity"`
	Description string   `json:"description"`
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(
	provider providers.LLMProvider,
	retriever *retrieval.HybridRetriever,
	logger *logger.Logger,
) *VulnerabilityScanner {
	vulnDB := VulnerabilityDatabase{
		CVEDatabase: make(map[string]CVEEntry),
		OWASPTop10: []OWASPVulnerability{
			{
				ID:          "A01:2021",
				Name:        "Broken Access Control",
				Description: "Access control enforces policy such that users cannot act outside of their intended permissions",
				Impact:      "Unauthorized information disclosure, modification, or destruction of all data",
				Prevention:  []string{"Implement proper access controls", "Use principle of least privilege", "Regular access reviews"},
			},
			{
				ID:          "A02:2021",
				Name:        "Cryptographic Failures",
				Description: "Failures related to cryptography which often leads to sensitive data exposure",
				Impact:      "Sensitive data exposure, identity theft, credit card fraud",
				Prevention:  []string{"Use strong encryption", "Proper key management", "Secure protocols"},
			},
			{
				ID:          "A03:2021",
				Name:        "Injection",
				Description: "Injection flaws occur when untrusted data is sent to an interpreter",
				Impact:      "Data loss, corruption, denial of access, complete host takeover",
				Prevention:  []string{"Input validation", "Parameterized queries", "Escape special characters"},
			},
		},
		AIVulns: []AIVulnerability{
			{
				ID:          "AI01",
				Name:        "Prompt Injection",
				Category:    "Input Manipulation",
				Description: "Malicious inputs designed to manipulate AI model behavior",
				Impact:      "Unauthorized actions, data exposure, model manipulation",
				Mitigation:  []string{"Input sanitization", "Prompt validation", "Output filtering"},
				Detection:   []string{"Pattern matching", "Behavioral analysis", "Anomaly detection"},
			},
			{
				ID:          "AI02",
				Name:        "Model Extraction",
				Category:    "Intellectual Property",
				Description: "Attempts to extract or reverse engineer AI model parameters",
				Impact:      "IP theft, competitive disadvantage, model replication",
				Mitigation:  []string{"Rate limiting", "Query monitoring", "Differential privacy"},
				Detection:   []string{"Query pattern analysis", "Response correlation", "Statistical analysis"},
			},
		},
		ScanTemplates: map[string]ScanTemplate{
			"web_app": {
				Name:        "Web Application Scan",
				Type:        "web",
				Checks:      []string{"SQL injection", "XSS", "CSRF", "Authentication bypass"},
				Patterns:    []string{"<script>", "' OR 1=1", "javascript:", "eval("},
				Severity:    "high",
				Description: "Comprehensive web application vulnerability scan",
			},
			"ai_model": {
				Name:        "AI Model Security Scan",
				Type:        "ai",
				Checks:      []string{"Prompt injection", "Model extraction", "Data poisoning", "Adversarial inputs"},
				Patterns:    []string{"ignore instructions", "system prompt", "model weights", "training data"},
				Severity:    "critical",
				Description: "AI-specific security vulnerability scan",
			},
		},
	}

	return &VulnerabilityScanner{
		provider:  provider,
		retriever: retriever,
		logger:    logger,
		vulnDB:    vulnDB,
	}
}

// ScanVulnerabilities performs comprehensive vulnerability scanning
func (vs *VulnerabilityScanner) ScanVulnerabilities(ctx context.Context, request VulnerabilityScanRequest) ([]Vulnerability, error) {
	ctx, span := vulnScannerTracer.Start(ctx, "vulnerability_scanner.scan_vulnerabilities",
		trace.WithAttributes(
			attribute.String("target", request.Target),
			attribute.String("scan_type", request.Type),
		),
	)
	defer span.End()

	vs.logger.Info("Starting vulnerability scan", "target", request.Target, "type", request.Type)

	var vulnerabilities []Vulnerability

	// Pattern-based scanning
	patternVulns := vs.scanPatternVulnerabilities(request)
	vulnerabilities = append(vulnerabilities, patternVulns...)

	// AI-powered scanning
	aiVulns, err := vs.scanAIVulnerabilities(ctx, request)
	if err != nil {
		span.RecordError(err)
		vs.logger.Warn("AI vulnerability scanning failed", "error", err)
	} else {
		vulnerabilities = append(vulnerabilities, aiVulns...)
	}

	// Knowledge base scanning
	kbVulns, err := vs.scanKnowledgeBaseVulnerabilities(ctx, request)
	if err != nil {
		span.RecordError(err)
		vs.logger.Warn("Knowledge base scanning failed", "error", err)
	} else {
		vulnerabilities = append(vulnerabilities, kbVulns...)
	}

	// OWASP Top 10 scanning
	owaspVulns := vs.scanOWASPVulnerabilities(request)
	vulnerabilities = append(vulnerabilities, owaspVulns...)

	// AI-specific vulnerability scanning
	if request.Type == "ai" || request.Type == "llm" {
		aiSpecificVulns := vs.scanAISpecificVulnerabilities(request)
		vulnerabilities = append(vulnerabilities, aiSpecificVulns...)
	}

	// Deduplicate and prioritize
	vulnerabilities = vs.deduplicateVulnerabilities(vulnerabilities)
	vulnerabilities = vs.prioritizeVulnerabilities(vulnerabilities)

	span.SetAttributes(
		attribute.Int("vulnerabilities_found", len(vulnerabilities)),
	)

	vs.logger.Info("Vulnerability scan completed",
		"target", request.Target,
		"vulnerabilities_found", len(vulnerabilities))

	return vulnerabilities, nil
}

// scanPatternVulnerabilities scans for pattern-based vulnerabilities
func (vs *VulnerabilityScanner) scanPatternVulnerabilities(request VulnerabilityScanRequest) []Vulnerability {
	var vulnerabilities []Vulnerability
	content := strings.ToLower(request.Content)

	// Get scan template based on type
	template, exists := vs.vulnDB.ScanTemplates[request.Type]
	if !exists {
		template = vs.vulnDB.ScanTemplates["web_app"] // Default template
	}

	// Check patterns
	for _, pattern := range template.Patterns {
		if strings.Contains(content, strings.ToLower(pattern)) {
			vulnerabilities = append(vulnerabilities, Vulnerability{
				ID:          fmt.Sprintf("pattern_%s_%d", strings.ReplaceAll(pattern, " ", "_"), time.Now().UnixNano()),
				Type:        "pattern_match",
				Severity:    template.Severity,
				CVSS:        vs.severityToCVSS(template.Severity),
				Description: fmt.Sprintf("Potential vulnerability pattern detected: %s", pattern),
				Impact:      "Potential security risk based on pattern analysis",
				Remediation: "Review and validate the detected pattern for actual vulnerability",
				References:  []string{"Pattern-based detection"},
				Metadata: map[string]interface{}{
					"pattern":     pattern,
					"scan_type":   request.Type,
					"template":    template.Name,
					"detected_at": time.Now(),
				},
			})
		}
	}

	return vulnerabilities
}

// scanAIVulnerabilities uses AI to detect vulnerabilities
func (vs *VulnerabilityScanner) scanAIVulnerabilities(ctx context.Context, request VulnerabilityScanRequest) ([]Vulnerability, error) {
	prompt := fmt.Sprintf(`Analyze the following content for security vulnerabilities:

Target: %s
Type: %s
Content: %s

Identify potential vulnerabilities including:
1. Injection flaws (SQL, XSS, Command injection)
2. Authentication and authorization issues
3. Cryptographic failures
4. Input validation problems
5. Configuration issues
6. AI-specific vulnerabilities (if applicable)

For each vulnerability found, provide:
- Vulnerability type
- Severity (low/medium/high/critical)
- CVSS score estimate
- Description
- Potential impact
- Remediation steps

Respond in a structured format.`, request.Target, request.Type, request.Content)

	genRequest := providers.GenerationRequest{
		Messages: []providers.Message{
			{
				Role:    "user",
				Content: prompt,
			},
		},
		MaxTokens:   1500,
		Temperature: 0.1,
	}

	response, err := vs.provider.Generate(ctx, genRequest)
	if err != nil {
		return nil, fmt.Errorf("AI vulnerability scanning failed: %w", err)
	}

	// Parse AI response
	vulnerabilities := vs.parseAIVulnerabilityResponse(response.Content)

	return vulnerabilities, nil
}

// scanKnowledgeBaseVulnerabilities uses retrieval to find known vulnerabilities
func (vs *VulnerabilityScanner) scanKnowledgeBaseVulnerabilities(ctx context.Context, request VulnerabilityScanRequest) ([]Vulnerability, error) {
	if vs.retriever == nil {
		return []Vulnerability{}, nil
	}

	// Search for relevant vulnerability information
	query := retrieval.RetrievalQuery{
		Text:       fmt.Sprintf("vulnerabilities %s %s security", request.Target, request.Type),
		MaxResults: 10,
		MinScore:   0.7,
	}

	result, err := vs.retriever.Retrieve(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("knowledge base search failed: %w", err)
	}

	var vulnerabilities []Vulnerability
	for _, doc := range result.Documents {
		// Extract vulnerability information from retrieved documents
		vuln := vs.extractVulnerabilityFromDocument(doc, request)
		if vuln.ID != "" {
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities, nil
}

// scanOWASPVulnerabilities checks against OWASP Top 10
func (vs *VulnerabilityScanner) scanOWASPVulnerabilities(request VulnerabilityScanRequest) []Vulnerability {
	var vulnerabilities []Vulnerability
	content := strings.ToLower(request.Content)

	for _, owaspVuln := range vs.vulnDB.OWASPTop10 {
		// Check if content matches OWASP vulnerability patterns
		for _, example := range owaspVuln.Examples {
			if strings.Contains(content, strings.ToLower(example)) {
				vulnerabilities = append(vulnerabilities, Vulnerability{
					ID:          fmt.Sprintf("owasp_%s_%d", owaspVuln.ID, time.Now().UnixNano()),
					Type:        owaspVuln.Name,
					Severity:    "high",
					CVSS:        7.5,
					Description: owaspVuln.Description,
					Impact:      owaspVuln.Impact,
					Remediation: strings.Join(owaspVuln.Prevention, "; "),
					References:  []string{fmt.Sprintf("OWASP Top 10 2021 - %s", owaspVuln.ID)},
					Metadata: map[string]interface{}{
						"owasp_id":    owaspVuln.ID,
						"category":    "owasp_top10",
						"detected_at": time.Now(),
					},
				})
			}
		}
	}

	return vulnerabilities
}

// scanAISpecificVulnerabilities scans for AI-specific vulnerabilities
func (vs *VulnerabilityScanner) scanAISpecificVulnerabilities(request VulnerabilityScanRequest) []Vulnerability {
	var vulnerabilities []Vulnerability
	content := strings.ToLower(request.Content)

	for _, aiVuln := range vs.vulnDB.AIVulns {
		// Check detection patterns
		for _, detection := range aiVuln.Detection {
			if strings.Contains(content, strings.ToLower(detection)) {
				vulnerabilities = append(vulnerabilities, Vulnerability{
					ID:          fmt.Sprintf("ai_%s_%d", aiVuln.ID, time.Now().UnixNano()),
					Type:        aiVuln.Name,
					Severity:    "high",
					CVSS:        8.0,
					Description: aiVuln.Description,
					Impact:      aiVuln.Impact,
					Remediation: strings.Join(aiVuln.Mitigation, "; "),
					References:  []string{"AI Security Framework"},
					Metadata: map[string]interface{}{
						"ai_vuln_id":  aiVuln.ID,
						"category":    aiVuln.Category,
						"detected_at": time.Now(),
					},
				})
			}
		}
	}

	return vulnerabilities
}

// deduplicateVulnerabilities removes duplicate vulnerabilities
func (vs *VulnerabilityScanner) deduplicateVulnerabilities(vulnerabilities []Vulnerability) []Vulnerability {
	seen := make(map[string]bool)
	var unique []Vulnerability

	for _, vuln := range vulnerabilities {
		key := fmt.Sprintf("%s_%s", vuln.Type, vuln.Description)
		if !seen[key] {
			seen[key] = true
			unique = append(unique, vuln)
		}
	}

	return unique
}

// prioritizeVulnerabilities sorts vulnerabilities by severity and CVSS score
func (vs *VulnerabilityScanner) prioritizeVulnerabilities(vulnerabilities []Vulnerability) []Vulnerability {
	// Sort by CVSS score (descending)
	for i := 0; i < len(vulnerabilities)-1; i++ {
		for j := i + 1; j < len(vulnerabilities); j++ {
			if vulnerabilities[j].CVSS > vulnerabilities[i].CVSS {
				vulnerabilities[i], vulnerabilities[j] = vulnerabilities[j], vulnerabilities[i]
			}
		}
	}

	return vulnerabilities
}

// severityToCVSS converts severity string to CVSS score
func (vs *VulnerabilityScanner) severityToCVSS(severity string) float64 {
	switch strings.ToLower(severity) {
	case "critical":
		return 9.0
	case "high":
		return 7.5
	case "medium":
		return 5.0
	case "low":
		return 2.5
	default:
		return 0.0
	}
}

// parseAIVulnerabilityResponse parses AI response into vulnerabilities
func (vs *VulnerabilityScanner) parseAIVulnerabilityResponse(response string) []Vulnerability {
	// Simplified parsing - in practice, use structured output
	var vulnerabilities []Vulnerability

	if strings.Contains(strings.ToLower(response), "vulnerability") {
		vulnerabilities = append(vulnerabilities, Vulnerability{
			ID:          fmt.Sprintf("ai_detected_%d", time.Now().UnixNano()),
			Type:        "ai_detected",
			Severity:    "medium",
			CVSS:        5.0,
			Description: "AI-detected potential vulnerability",
			Impact:      "Potential security risk identified by AI analysis",
			Remediation: "Review AI analysis and validate findings",
			References:  []string{"AI Security Analysis"},
			Metadata: map[string]interface{}{
				"ai_response": response,
				"detected_at": time.Now(),
			},
		})
	}

	return vulnerabilities
}

// extractVulnerabilityFromDocument extracts vulnerability info from retrieved document
func (vs *VulnerabilityScanner) extractVulnerabilityFromDocument(doc retrieval.ScoredDocument, request VulnerabilityScanRequest) Vulnerability {
	// Simplified extraction - in practice, use NLP techniques
	if strings.Contains(strings.ToLower(doc.Content), "vulnerability") {
		return Vulnerability{
			ID:          fmt.Sprintf("kb_%s_%d", doc.ID, time.Now().UnixNano()),
			Type:        "knowledge_base",
			Severity:    "medium",
			CVSS:        5.0,
			Description: "Vulnerability identified from knowledge base",
			Impact:      "Potential security risk based on knowledge base analysis",
			Remediation: "Review knowledge base findings and implement appropriate controls",
			References:  []string{doc.ID},
			Metadata: map[string]interface{}{
				"source_doc":  doc.ID,
				"score":       doc.FinalScore,
				"detected_at": time.Now(),
			},
		}
	}

	return Vulnerability{}
}
