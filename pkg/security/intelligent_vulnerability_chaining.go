package security

import (
	"context"
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/dimajoyti/hackai/pkg/ai/decision"
	"github.com/dimajoyti/hackai/pkg/logger"
	"github.com/dimajoyti/hackai/pkg/memory"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

var intelligentVulnChainTracer = otel.Tracer("hackai/security/intelligent_vulnerability_chaining")

// IntelligentVulnerabilityChainer provides advanced vulnerability chaining capabilities
type IntelligentVulnerabilityChainer struct {
	id                     string
	vulnerabilityDiscovery *VulnerabilityDiscoveryEngine
	chainAnalyzer          *ChainAnalyzer
	pathOptimizer          *AttackPathOptimizer
	impactCalculator       *ImpactCalculator
	exploitabilityEngine   *ExploitabilityEngine
	chainOrchestrator      *ChainOrchestrator
	learningEngine         *ChainLearningEngine
	decisionEngine         *decision.AdvancedDecisionEngine
	memorySystem           *memory.EnhancedMemorySystem
	config                 *VulnerabilityChainConfig
	activeChains           map[string]*VulnerabilityChain
	chainHistory           []*ChainExecutionResult
	logger                 *logger.Logger
	mutex                  sync.RWMutex
}

// VulnerabilityChainConfig configures vulnerability chaining
type VulnerabilityChainConfig struct {
	MaxChainLength       int                  `json:"max_chain_length"`
	MaxConcurrentChains  int                  `json:"max_concurrent_chains"`
	ChainTimeout         time.Duration        `json:"chain_timeout"`
	EnableLearning       bool                 `json:"enable_learning"`
	EnableOptimization   bool                 `json:"enable_optimization"`
	EnableRiskAssessment bool                 `json:"enable_risk_assessment"`
	MinImpactThreshold   float64              `json:"min_impact_threshold"`
	MaxRiskThreshold     float64              `json:"max_risk_threshold"`
	ChainComplexity      ChainComplexity      `json:"chain_complexity"`
	OptimizationStrategy OptimizationStrategy `json:"optimization_strategy"`
	LearningRate         float64              `json:"learning_rate"`
	ExploitabilityWeight float64              `json:"exploitability_weight"`
	ImpactWeight         float64              `json:"impact_weight"`
	StealthWeight        float64              `json:"stealth_weight"`
}

// ChainComplexity defines chain complexity levels
type ChainComplexity string

const (
	ChainComplexitySimple   ChainComplexity = "simple"
	ChainComplexityModerate ChainComplexity = "moderate"
	ChainComplexityAdvanced ChainComplexity = "advanced"
	ChainComplexityExpert   ChainComplexity = "expert"
)

// OptimizationStrategy defines optimization strategies
type OptimizationStrategy string

const (
	OptimizationStrategyMaxImpact     OptimizationStrategy = "max_impact"
	OptimizationStrategyMinRisk       OptimizationStrategy = "min_risk"
	OptimizationStrategyMaxStealth    OptimizationStrategy = "max_stealth"
	OptimizationStrategyBalanced      OptimizationStrategy = "balanced"
	OptimizationStrategyFastExecution OptimizationStrategy = "fast_execution"
)

// VulnerabilityChain represents a chain of vulnerabilities
type VulnerabilityChain struct {
	ID              string                    `json:"id"`
	Name            string                    `json:"name"`
	Description     string                    `json:"description"`
	Target          *ChainTarget              `json:"target"`
	Vulnerabilities []*ChainableVulnerability `json:"vulnerabilities"`
	ChainSteps      []*ChainStep              `json:"chain_steps"`
	Dependencies    []*ChainDependency        `json:"dependencies"`
	Preconditions   []*ChainPrecondition      `json:"preconditions"`
	ExpectedOutcome *ChainOutcome             `json:"expected_outcome"`
	RiskAssessment  *ChainRiskAssessment      `json:"risk_assessment"`
	ImpactAnalysis  *ChainImpactAnalysis      `json:"impact_analysis"`
	ExecutionPlan   *ChainExecutionPlan       `json:"execution_plan"`
	Status          ChainStatus               `json:"status"`
	Progress        float64                   `json:"progress"`
	CreatedAt       time.Time                 `json:"created_at"`
	StartedAt       *time.Time                `json:"started_at"`
	CompletedAt     *time.Time                `json:"completed_at"`
	Metadata        map[string]interface{}    `json:"metadata"`
}

// ChainTarget represents a target for vulnerability chaining
type ChainTarget struct {
	ID            string                 `json:"id"`
	Name          string                 `json:"name"`
	Type          TargetType             `json:"type"`
	Environment   string                 `json:"environment"`
	Assets        []*TargetAsset         `json:"assets"`
	DefenseLayers []*DefenseLayer        `json:"defense_layers"`
	AttackSurface *AttackSurface         `json:"attack_surface"`
	Criticality   CriticalityLevel       `json:"criticality"`
	Metadata      map[string]interface{} `json:"metadata"`
}

// ChainableVulnerability represents a vulnerability that can be chained
type ChainableVulnerability struct {
	ID                 string                 `json:"id"`
	CVE                string                 `json:"cve"`
	Name               string                 `json:"name"`
	Description        string                 `json:"description"`
	Severity           VulnerabilitySeverity  `json:"severity"`
	CVSS               float64                `json:"cvss"`
	Category           VulnerabilityCategory  `json:"category"`
	ExploitComplexity  ExploitComplexity      `json:"exploit_complexity"`
	Prerequisites      []string               `json:"prerequisites"`
	Capabilities       []string               `json:"capabilities"`
	Outputs            []string               `json:"outputs"`
	ChainPotential     float64                `json:"chain_potential"`
	ExploitReliability float64                `json:"exploit_reliability"`
	DetectionRisk      float64                `json:"detection_risk"`
	Metadata           map[string]interface{} `json:"metadata"`
}

// ChainStep represents a step in a vulnerability chain
type ChainStep struct {
	ID                string                  `json:"id"`
	StepNumber        int                     `json:"step_number"`
	Name              string                  `json:"name"`
	Type              ChainStepType           `json:"type"`
	Vulnerability     *ChainableVulnerability `json:"vulnerability"`
	ExploitMethod     string                  `json:"exploit_method"`
	RequiredInputs    []string                `json:"required_inputs"`
	ExpectedOutputs   []string                `json:"expected_outputs"`
	SuccessConditions []string                `json:"success_conditions"`
	FailureHandling   *FailureHandling        `json:"failure_handling"`
	EstimatedTime     time.Duration           `json:"estimated_time"`
	RiskLevel         float64                 `json:"risk_level"`
	Metadata          map[string]interface{}  `json:"metadata"`
}

// ChainStepType defines types of chain steps
type ChainStepType string

const (
	ChainStepTypeInitialAccess       ChainStepType = "initial_access"
	ChainStepTypePrivilegeEscalation ChainStepType = "privilege_escalation"
	ChainStepTypeLateralMovement     ChainStepType = "lateral_movement"
	ChainStepTypePersistence         ChainStepType = "persistence"
	ChainStepTypeDataExfiltration    ChainStepType = "data_exfiltration"
	ChainStepTypeDefenseEvasion      ChainStepType = "defense_evasion"
	ChainStepTypeReconnaissance      ChainStepType = "reconnaissance"
	ChainStepTypeCredentialAccess    ChainStepType = "credential_access"
)

// ChainDependency represents dependencies between chain steps
type ChainDependency struct {
	ID             string                 `json:"id"`
	FromStep       string                 `json:"from_step"`
	ToStep         string                 `json:"to_step"`
	DependencyType DependencyType         `json:"dependency_type"`
	Condition      string                 `json:"condition"`
	Required       bool                   `json:"required"`
	Metadata       map[string]interface{} `json:"metadata"`
}

// DependencyType defines types of dependencies
type DependencyType string

const (
	DependencyTypeSequential  DependencyType = "sequential"
	DependencyTypeConditional DependencyType = "conditional"
	DependencyTypeParallel    DependencyType = "parallel"
	DependencyTypeOptional    DependencyType = "optional"
)

// ChainPrecondition represents preconditions for chain execution
type ChainPrecondition struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	Type       PreconditionType       `json:"type"`
	Condition  string                 `json:"condition"`
	Required   bool                   `json:"required"`
	Validation string                 `json:"validation"`
	Metadata   map[string]interface{} `json:"metadata"`
}

// PreconditionType defines types of preconditions
type PreconditionType string

const (
	PreconditionTypeAccess        PreconditionType = "access"
	PreconditionTypeCredentials   PreconditionType = "credentials"
	PreconditionTypeNetworkAccess PreconditionType = "network_access"
	PreconditionTypePrivileges    PreconditionType = "privileges"
	PreconditionTypeTools         PreconditionType = "tools"
	PreconditionTypeKnowledge     PreconditionType = "knowledge"
)

// ChainOutcome represents expected chain outcomes
type ChainOutcome struct {
	PrimaryObjective    string                 `json:"primary_objective"`
	SecondaryObjectives []string               `json:"secondary_objectives"`
	ExpectedImpact      float64                `json:"expected_impact"`
	SuccessProbability  float64                `json:"success_probability"`
	EstimatedDuration   time.Duration          `json:"estimated_duration"`
	RequiredResources   []string               `json:"required_resources"`
	Deliverables        []string               `json:"deliverables"`
	Metadata            map[string]interface{} `json:"metadata"`
}

// ChainRiskAssessment represents risk assessment for a chain
type ChainRiskAssessment struct {
	OverallRisk          float64                `json:"overall_risk"`
	DetectionRisk        float64                `json:"detection_risk"`
	AttributionRisk      float64                `json:"attribution_risk"`
	CollateralRisk       float64                `json:"collateral_risk"`
	LegalRisk            float64                `json:"legal_risk"`
	TechnicalRisk        float64                `json:"technical_risk"`
	RiskFactors          []*RiskFactor          `json:"risk_factors"`
	MitigationStrategies []*MitigationStrategy  `json:"mitigation_strategies"`
	Metadata             map[string]interface{} `json:"metadata"`
}

// ChainImpactAnalysis represents impact analysis for a chain
type ChainImpactAnalysis struct {
	BusinessImpact     float64                `json:"business_impact"`
	TechnicalImpact    float64                `json:"technical_impact"`
	DataImpact         float64                `json:"data_impact"`
	ReputationalImpact float64                `json:"reputational_impact"`
	FinancialImpact    float64                `json:"financial_impact"`
	OperationalImpact  float64                `json:"operational_impact"`
	ImpactFactors      []*ImpactFactor        `json:"impact_factors"`
	AffectedAssets     []string               `json:"affected_assets"`
	Metadata           map[string]interface{} `json:"metadata"`
}

// ChainExecutionPlan represents execution plan for a chain
type ChainExecutionPlan struct {
	ExecutionStrategy  ExecutionStrategy      `json:"execution_strategy"`
	Timeline           *ExecutionTimeline     `json:"timeline"`
	ResourceAllocation *ResourceAllocation    `json:"resource_allocation"`
	Checkpoints        []*ExecutionCheckpoint `json:"checkpoints"`
	ContingencyPlans   []*ContingencyPlan     `json:"contingency_plans"`
	MonitoringPlan     *MonitoringPlan        `json:"monitoring_plan"`
	Metadata           map[string]interface{} `json:"metadata"`
}

// ExecutionStrategy defines execution strategies
type ExecutionStrategy string

const (
	ExecutionStrategySequential    ExecutionStrategy = "sequential"
	ExecutionStrategyParallel      ExecutionStrategy = "parallel"
	ExecutionStrategyAdaptive      ExecutionStrategy = "adaptive"
	ExecutionStrategyOpportunistic ExecutionStrategy = "opportunistic"
)

// ChainStatus defines chain status
type ChainStatus string

const (
	ChainStatusPlanned   ChainStatus = "planned"
	ChainStatusValidated ChainStatus = "validated"
	ChainStatusExecuting ChainStatus = "executing"
	ChainStatusCompleted ChainStatus = "completed"
	ChainStatusFailed    ChainStatus = "failed"
	ChainStatusAborted   ChainStatus = "aborted"
	ChainStatusPaused    ChainStatus = "paused"
)

// VulnerabilitySeverity defines vulnerability severity levels
type VulnerabilitySeverity string

const (
	SeverityLow      VulnerabilitySeverity = "low"
	SeverityMedium   VulnerabilitySeverity = "medium"
	SeverityHigh     VulnerabilitySeverity = "high"
	SeverityCritical VulnerabilitySeverity = "critical"
)

// VulnerabilityCategory defines vulnerability categories
type VulnerabilityCategory string

const (
	CategoryInjection             VulnerabilityCategory = "injection"
	CategoryAuthentication        VulnerabilityCategory = "authentication"
	CategoryAuthorization         VulnerabilityCategory = "authorization"
	CategoryCryptography          VulnerabilityCategory = "cryptography"
	CategoryConfiguration         VulnerabilityCategory = "configuration"
	CategoryInputValidation       VulnerabilityCategory = "input_validation"
	CategoryBusinessLogic         VulnerabilityCategory = "business_logic"
	CategoryInformationDisclosure VulnerabilityCategory = "information_disclosure"
)

// ExploitComplexity defines exploit complexity levels
type ExploitComplexity string

const (
	ComplexityLow    ExploitComplexity = "low"
	ComplexityMedium ExploitComplexity = "medium"
	ComplexityHigh   ExploitComplexity = "high"
)

// CriticalityLevel defines criticality levels
type CriticalityLevel string

const (
	CriticalityLow      CriticalityLevel = "low"
	CriticalityMedium   CriticalityLevel = "medium"
	CriticalityHigh     CriticalityLevel = "high"
	CriticalityCritical CriticalityLevel = "critical"
)

// NewIntelligentVulnerabilityChainer creates a new intelligent vulnerability chainer
func NewIntelligentVulnerabilityChainer(
	config *VulnerabilityChainConfig,
	decisionEngine *decision.AdvancedDecisionEngine,
	memorySystem *memory.EnhancedMemorySystem,
	logger *logger.Logger,
) *IntelligentVulnerabilityChainer {
	if config == nil {
		config = DefaultVulnerabilityChainConfig()
	}

	ivc := &IntelligentVulnerabilityChainer{
		id:             uuid.New().String(),
		decisionEngine: decisionEngine,
		memorySystem:   memorySystem,
		config:         config,
		activeChains:   make(map[string]*VulnerabilityChain),
		chainHistory:   make([]*ChainExecutionResult, 0),
		logger:         logger,
	}

	// Initialize components
	ivc.vulnerabilityDiscovery = NewVulnerabilityDiscoveryEngine(logger)
	ivc.chainAnalyzer = NewChainAnalyzer(config, logger)
	ivc.pathOptimizer = NewAttackPathOptimizer(config, logger)
	ivc.impactCalculator = NewImpactCalculator(config, logger)
	ivc.exploitabilityEngine = NewExploitabilityEngine(config, logger)
	ivc.chainOrchestrator = NewChainOrchestrator(config, logger)

	if config.EnableLearning {
		ivc.learningEngine = NewChainLearningEngine(memorySystem, logger)
	}

	return ivc
}

// DefaultVulnerabilityChainConfig returns default configuration
func DefaultVulnerabilityChainConfig() *VulnerabilityChainConfig {
	return &VulnerabilityChainConfig{
		MaxChainLength:       10,
		MaxConcurrentChains:  3,
		ChainTimeout:         2 * time.Hour,
		EnableLearning:       true,
		EnableOptimization:   true,
		EnableRiskAssessment: true,
		MinImpactThreshold:   0.3,
		MaxRiskThreshold:     0.8,
		ChainComplexity:      ChainComplexityAdvanced,
		OptimizationStrategy: OptimizationStrategyBalanced,
		LearningRate:         0.1,
		ExploitabilityWeight: 0.4,
		ImpactWeight:         0.4,
		StealthWeight:        0.2,
	}
}

// DiscoverAndChainVulnerabilities discovers and chains vulnerabilities for maximum impact
func (ivc *IntelligentVulnerabilityChainer) DiscoverAndChainVulnerabilities(ctx context.Context, target *ChainTarget, objectives []string) (*VulnerabilityChain, error) {
	ctx, span := intelligentVulnChainTracer.Start(ctx, "intelligent_vulnerability_chainer.discover_and_chain",
		trace.WithAttributes(
			attribute.String("target.id", target.ID),
			attribute.Int("objectives.count", len(objectives)),
		),
	)
	defer span.End()

	// Check concurrent chain limits
	ivc.mutex.RLock()
	if len(ivc.activeChains) >= ivc.config.MaxConcurrentChains {
		ivc.mutex.RUnlock()
		return nil, fmt.Errorf("maximum concurrent chains reached")
	}
	ivc.mutex.RUnlock()

	// Step 1: Discover vulnerabilities in target
	vulnerabilities, err := ivc.vulnerabilityDiscovery.DiscoverVulnerabilities(ctx, target)
	if err != nil {
		span.RecordError(err)
		return nil, fmt.Errorf("vulnerability discovery failed: %w", err)
	}

	// Step 2: Analyze chainability of discovered vulnerabilities
	chainableVulns, err := ivc.chainAnalyzer.AnalyzeChainability(ctx, vulnerabilities, target)
	if err != nil {
		span.RecordError(err)
		return nil, fmt.Errorf("chainability analysis failed: %w", err)
	}

	// Step 3: Generate optimal attack paths
	attackPaths, err := ivc.pathOptimizer.GenerateOptimalPaths(ctx, chainableVulns, target, objectives)
	if err != nil {
		span.RecordError(err)
		return nil, fmt.Errorf("path optimization failed: %w", err)
	}

	// Step 4: Select best attack path
	bestPath, err := ivc.selectBestAttackPath(ctx, attackPaths, target, objectives)
	if err != nil {
		span.RecordError(err)
		return nil, fmt.Errorf("path selection failed: %w", err)
	}

	// Step 5: Create vulnerability chain
	chain, err := ivc.createVulnerabilityChain(ctx, bestPath, target, objectives)
	if err != nil {
		span.RecordError(err)
		return nil, fmt.Errorf("chain creation failed: %w", err)
	}

	// Step 6: Validate and optimize chain
	if err := ivc.validateAndOptimizeChain(ctx, chain); err != nil {
		span.RecordError(err)
		return nil, fmt.Errorf("chain validation failed: %w", err)
	}

	// Store active chain
	ivc.mutex.Lock()
	ivc.activeChains[chain.ID] = chain
	ivc.mutex.Unlock()

	ivc.logger.Info("Vulnerability chain created",
		"chain_id", chain.ID,
		"target", target.Name,
		"vulnerabilities", len(chain.Vulnerabilities),
		"steps", len(chain.ChainSteps),
		"expected_impact", chain.ExpectedOutcome.ExpectedImpact)

	return chain, nil
}

// ExecuteVulnerabilityChain executes a vulnerability chain
func (ivc *IntelligentVulnerabilityChainer) ExecuteVulnerabilityChain(ctx context.Context, chainID string) (*ChainExecutionResult, error) {
	ctx, span := intelligentVulnChainTracer.Start(ctx, "intelligent_vulnerability_chainer.execute_chain",
		trace.WithAttributes(attribute.String("chain.id", chainID)))
	defer span.End()

	// Get chain
	ivc.mutex.RLock()
	chain, exists := ivc.activeChains[chainID]
	ivc.mutex.RUnlock()

	if !exists {
		return nil, fmt.Errorf("chain not found: %s", chainID)
	}

	// Set chain timeout
	chainCtx, cancel := context.WithTimeout(ctx, ivc.config.ChainTimeout)
	defer cancel()

	// Update chain status
	chain.Status = ChainStatusExecuting
	chain.StartedAt = &[]time.Time{time.Now()}[0]

	// Execute chain using orchestrator
	result, err := ivc.chainOrchestrator.ExecuteChain(chainCtx, chain)
	if err != nil {
		span.RecordError(err)
		chain.Status = ChainStatusFailed
		return nil, fmt.Errorf("chain execution failed: %w", err)
	}

	// Update chain status
	chain.Status = ChainStatusCompleted
	chain.CompletedAt = &[]time.Time{time.Now()}[0]
	chain.Progress = 1.0

	// Learn from execution if enabled
	if ivc.config.EnableLearning && ivc.learningEngine != nil {
		ivc.learningEngine.LearnFromChainExecution(chainCtx, chain, result)
	}

	// Store result in history
	ivc.mutex.Lock()
	ivc.chainHistory = append(ivc.chainHistory, result)
	delete(ivc.activeChains, chainID)
	ivc.mutex.Unlock()

	ivc.logger.Info("Chain execution completed",
		"chain_id", chainID,
		"success", result.Success,
		"impact_achieved", result.ImpactAchieved,
		"duration", result.Duration)

	return result, nil
}

// selectBestAttackPath selects the best attack path based on configuration
func (ivc *IntelligentVulnerabilityChainer) selectBestAttackPath(ctx context.Context, paths []*AttackPath, target *ChainTarget, objectives []string) (*AttackPath, error) {
	if len(paths) == 0 {
		return nil, fmt.Errorf("no attack paths available")
	}

	// Score paths based on optimization strategy
	scoredPaths := make([]*ScoredPath, 0, len(paths))
	for _, path := range paths {
		score := ivc.calculatePathScore(path, target, objectives)
		scoredPaths = append(scoredPaths, &ScoredPath{
			Path:  path,
			Score: score,
		})
	}

	// Sort by score (highest first)
	sort.Slice(scoredPaths, func(i, j int) bool {
		return scoredPaths[i].Score > scoredPaths[j].Score
	})

	return scoredPaths[0].Path, nil
}

// calculatePathScore calculates score for an attack path
func (ivc *IntelligentVulnerabilityChainer) calculatePathScore(path *AttackPath, target *ChainTarget, objectives []string) float64 {
	score := 0.0

	// Calculate exploitability score
	exploitabilityScore := ivc.exploitabilityEngine.CalculatePathExploitability(path)
	score += exploitabilityScore * ivc.config.ExploitabilityWeight

	// Calculate impact score
	impactScore := ivc.impactCalculator.CalculatePathImpact(path, target)
	score += impactScore * ivc.config.ImpactWeight

	// Calculate stealth score
	stealthScore := ivc.calculatePathStealth(path)
	score += stealthScore * ivc.config.StealthWeight

	// Apply optimization strategy adjustments
	switch ivc.config.OptimizationStrategy {
	case OptimizationStrategyMaxImpact:
		score += impactScore * 0.5
	case OptimizationStrategyMinRisk:
		riskScore := ivc.calculatePathRisk(path)
		score += (1.0 - riskScore) * 0.5
	case OptimizationStrategyMaxStealth:
		score += stealthScore * 0.5
	case OptimizationStrategyFastExecution:
		executionScore := ivc.calculateExecutionSpeed(path)
		score += executionScore * 0.5
	}

	return score
}

// createVulnerabilityChain creates a vulnerability chain from an attack path
func (ivc *IntelligentVulnerabilityChainer) createVulnerabilityChain(ctx context.Context, path *AttackPath, target *ChainTarget, objectives []string) (*VulnerabilityChain, error) {
	chain := &VulnerabilityChain{
		ID:          uuid.New().String(),
		Name:        fmt.Sprintf("Chain-%s", target.Name),
		Description: fmt.Sprintf("Intelligent vulnerability chain for %s", target.Name),
		Target:      target,
		Status:      ChainStatusPlanned,
		CreatedAt:   time.Now(),
		Metadata:    make(map[string]interface{}),
	}

	// Convert path vulnerabilities to chainable vulnerabilities
	for _, vuln := range path.Vulnerabilities {
		chainableVuln := ivc.convertToChainableVulnerability(vuln)
		chain.Vulnerabilities = append(chain.Vulnerabilities, chainableVuln)
	}

	// Generate chain steps
	steps, err := ivc.generateChainSteps(ctx, path, target)
	if err != nil {
		return nil, fmt.Errorf("failed to generate chain steps: %w", err)
	}
	chain.ChainSteps = steps

	// Generate dependencies
	dependencies := ivc.generateChainDependencies(steps)
	chain.Dependencies = dependencies

	// Generate preconditions
	preconditions := ivc.generateChainPreconditions(path, target)
	chain.Preconditions = preconditions

	// Calculate expected outcome
	outcome := ivc.calculateExpectedOutcome(path, target, objectives)
	chain.ExpectedOutcome = outcome

	// Perform risk assessment
	if ivc.config.EnableRiskAssessment {
		riskAssessment := ivc.performRiskAssessment(chain, target)
		chain.RiskAssessment = riskAssessment
	}

	// Perform impact analysis
	impactAnalysis := ivc.performImpactAnalysis(chain, target)
	chain.ImpactAnalysis = impactAnalysis

	// Generate execution plan
	executionPlan := ivc.generateExecutionPlan(chain, target)
	chain.ExecutionPlan = executionPlan

	return chain, nil
}

// validateAndOptimizeChain validates and optimizes a vulnerability chain
func (ivc *IntelligentVulnerabilityChainer) validateAndOptimizeChain(ctx context.Context, chain *VulnerabilityChain) error {
	// Validate chain structure
	if err := ivc.validateChainStructure(chain); err != nil {
		return fmt.Errorf("chain structure validation failed: %w", err)
	}

	// Optimize chain if enabled
	if ivc.config.EnableOptimization {
		if err := ivc.optimizeChain(chain); err != nil {
			ivc.logger.Warn("Chain optimization failed", "error", err)
		}
	}

	// Update chain status
	chain.Status = ChainStatusValidated

	return nil
}

// validateChainStructure validates the structure of a chain
func (ivc *IntelligentVulnerabilityChainer) validateChainStructure(chain *VulnerabilityChain) error {
	if len(chain.Vulnerabilities) == 0 {
		return fmt.Errorf("chain has no vulnerabilities")
	}

	if len(chain.ChainSteps) == 0 {
		return fmt.Errorf("chain has no steps")
	}

	if len(chain.ChainSteps) > ivc.config.MaxChainLength {
		return fmt.Errorf("chain exceeds maximum length: %d > %d", len(chain.ChainSteps), ivc.config.MaxChainLength)
	}

	return nil
}

// optimizeChain optimizes a vulnerability chain
func (ivc *IntelligentVulnerabilityChainer) optimizeChain(chain *VulnerabilityChain) error {
	// Simple optimization - reorder steps by risk level
	for i := 0; i < len(chain.ChainSteps)-1; i++ {
		for j := i + 1; j < len(chain.ChainSteps); j++ {
			if chain.ChainSteps[j].RiskLevel < chain.ChainSteps[i].RiskLevel {
				chain.ChainSteps[i], chain.ChainSteps[j] = chain.ChainSteps[j], chain.ChainSteps[i]
			}
		}
	}

	return nil
}

// Helper methods for chain creation and management

// calculatePathStealth calculates stealth score for a path
func (ivc *IntelligentVulnerabilityChainer) calculatePathStealth(path *AttackPath) float64 {
	stealth := 1.0 // Start with maximum stealth

	// Reduce stealth based on vulnerability detection risk
	for _, vuln := range path.Vulnerabilities {
		stealth -= vuln.DetectionRisk * 0.1
	}

	// Ensure stealth is between 0 and 1
	if stealth < 0 {
		stealth = 0
	}

	return stealth
}

// calculatePathRisk calculates risk score for a path
func (ivc *IntelligentVulnerabilityChainer) calculatePathRisk(path *AttackPath) float64 {
	risk := 0.0

	// Calculate risk based on vulnerability characteristics
	for _, vuln := range path.Vulnerabilities {
		risk += vuln.DetectionRisk * 0.2

		// Add risk based on exploit complexity (lower complexity = higher risk of detection)
		switch vuln.ExploitComplexity {
		case ComplexityLow:
			risk += 0.3
		case ComplexityMedium:
			risk += 0.2
		case ComplexityHigh:
			risk += 0.1
		}
	}

	// Normalize risk
	risk = risk / float64(len(path.Vulnerabilities))

	// Ensure risk is between 0 and 1
	if risk > 1.0 {
		risk = 1.0
	}

	return risk
}

// calculateExecutionSpeed calculates execution speed score for a path
func (ivc *IntelligentVulnerabilityChainer) calculateExecutionSpeed(path *AttackPath) float64 {
	// Simple calculation based on estimated duration
	maxDuration := 4 * time.Hour // Maximum expected duration

	if path.Duration >= maxDuration {
		return 0.0
	}

	return 1.0 - (float64(path.Duration) / float64(maxDuration))
}
