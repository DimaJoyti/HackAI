package security

import (
	"context"
	"fmt"
	"time"

	"github.com/dimajoyti/hackai/pkg/logger"
	"github.com/google/uuid"
)

// Supporting types and components for intelligent vulnerability chaining

// AttackPath represents an attack path through vulnerabilities
type AttackPath struct {
	ID              string                    `json:"id"`
	Name            string                    `json:"name"`
	Vulnerabilities []*ChainableVulnerability `json:"vulnerabilities"`
	Steps           []*PathStep               `json:"steps"`
	Complexity      float64                   `json:"complexity"`
	Reliability     float64                   `json:"reliability"`
	Impact          float64                   `json:"impact"`
	Risk            float64                   `json:"risk"`
	Stealth         float64                   `json:"stealth"`
	Duration        time.Duration             `json:"duration"`
	Metadata        map[string]interface{}    `json:"metadata"`
}

// PathStep represents a step in an attack path
type PathStep struct {
	ID            string                  `json:"id"`
	StepNumber    int                     `json:"step_number"`
	Vulnerability *ChainableVulnerability `json:"vulnerability"`
	Action        string                  `json:"action"`
	Prerequisites []string                `json:"prerequisites"`
	Outputs       []string                `json:"outputs"`
	Metadata      map[string]interface{}  `json:"metadata"`
}

// ScoredPath represents a path with its calculated score
type ScoredPath struct {
	Path  *AttackPath `json:"path"`
	Score float64     `json:"score"`
}

// ChainExecutionResult represents the result of chain execution
type ChainExecutionResult struct {
	ChainID        string                 `json:"chain_id"`
	Success        bool                   `json:"success"`
	StepsCompleted int                    `json:"steps_completed"`
	TotalSteps     int                    `json:"total_steps"`
	ImpactAchieved float64                `json:"impact_achieved"`
	Duration       time.Duration          `json:"duration"`
	Errors         []string               `json:"errors"`
	Artifacts      []string               `json:"artifacts"`
	LessonsLearned []string               `json:"lessons_learned"`
	Metadata       map[string]interface{} `json:"metadata"`
}

// Additional supporting types
type TargetAsset struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Type        string                 `json:"type"`
	Value       float64                `json:"value"`
	Criticality CriticalityLevel       `json:"criticality"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type DefenseLayer struct {
	ID            string                 `json:"id"`
	Name          string                 `json:"name"`
	Type          string                 `json:"type"`
	Effectiveness float64                `json:"effectiveness"`
	Coverage      []string               `json:"coverage"`
	Metadata      map[string]interface{} `json:"metadata"`
}

type FailureHandling struct {
	Strategy   string                 `json:"strategy"`
	Fallback   string                 `json:"fallback"`
	Retry      bool                   `json:"retry"`
	MaxRetries int                    `json:"max_retries"`
	Metadata   map[string]interface{} `json:"metadata"`
}

type MitigationStrategy struct {
	ID            string                 `json:"id"`
	Name          string                 `json:"name"`
	Effectiveness float64                `json:"effectiveness"`
	Cost          float64                `json:"cost"`
	Metadata      map[string]interface{} `json:"metadata"`
}

type ImpactFactor struct {
	ID       string                 `json:"id"`
	Name     string                 `json:"name"`
	Weight   float64                `json:"weight"`
	Value    float64                `json:"value"`
	Metadata map[string]interface{} `json:"metadata"`
}

type ExecutionTimeline struct {
	StartTime  time.Time              `json:"start_time"`
	EndTime    time.Time              `json:"end_time"`
	Milestones []string               `json:"milestones"`
	Metadata   map[string]interface{} `json:"metadata"`
}

type ResourceAllocation struct {
	Agents      []string               `json:"agents"`
	Tools       []string               `json:"tools"`
	Credentials []string               `json:"credentials"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type ExecutionCheckpoint struct {
	ID        string                 `json:"id"`
	Name      string                 `json:"name"`
	Condition string                 `json:"condition"`
	Action    string                 `json:"action"`
	Metadata  map[string]interface{} `json:"metadata"`
}

type MonitoringPlan struct {
	Metrics    []string               `json:"metrics"`
	Thresholds map[string]float64     `json:"thresholds"`
	Alerts     []string               `json:"alerts"`
	Metadata   map[string]interface{} `json:"metadata"`
}

// VulnerabilityDiscoveryEngine discovers vulnerabilities in targets
type VulnerabilityDiscoveryEngine struct {
	logger *logger.Logger
}

// NewVulnerabilityDiscoveryEngine creates a new vulnerability discovery engine
func NewVulnerabilityDiscoveryEngine(logger *logger.Logger) *VulnerabilityDiscoveryEngine {
	return &VulnerabilityDiscoveryEngine{
		logger: logger,
	}
}

// DiscoverVulnerabilities discovers vulnerabilities in a target
func (vde *VulnerabilityDiscoveryEngine) DiscoverVulnerabilities(ctx context.Context, target *ChainTarget) ([]*ChainableVulnerability, error) {
	var vulnerabilities []*ChainableVulnerability

	// Simulate vulnerability discovery based on target type
	switch target.Type {
	case TargetTypeWebApplication:
		vulnerabilities = append(vulnerabilities, vde.generateWebVulnerabilities()...)
	case TargetTypeNetworkInfra:
		vulnerabilities = append(vulnerabilities, vde.generateNetworkVulnerabilities()...)
	case TargetTypeCloudService:
		vulnerabilities = append(vulnerabilities, vde.generateCloudVulnerabilities()...)
	default:
		vulnerabilities = append(vulnerabilities, vde.generateGenericVulnerabilities()...)
	}

	vde.logger.Info("Vulnerabilities discovered",
		"target", target.Name,
		"count", len(vulnerabilities))

	return vulnerabilities, nil
}

// generateWebVulnerabilities generates web application vulnerabilities
func (vde *VulnerabilityDiscoveryEngine) generateWebVulnerabilities() []*ChainableVulnerability {
	return []*ChainableVulnerability{
		{
			ID:                 uuid.New().String(),
			CVE:                "CVE-2023-1234",
			Name:               "SQL Injection",
			Description:        "SQL injection vulnerability in login form",
			Severity:           SeverityHigh,
			CVSS:               8.5,
			Category:           CategoryInjection,
			ExploitComplexity:  ComplexityLow,
			Prerequisites:      []string{"network_access", "web_interface"},
			Capabilities:       []string{"data_extraction", "authentication_bypass"},
			Outputs:            []string{"database_access", "user_credentials"},
			ChainPotential:     0.8,
			ExploitReliability: 0.9,
			DetectionRisk:      0.3,
			Metadata:           make(map[string]interface{}),
		},
		{
			ID:                 uuid.New().String(),
			CVE:                "CVE-2023-5678",
			Name:               "Cross-Site Scripting (XSS)",
			Description:        "Stored XSS vulnerability in comment system",
			Severity:           SeverityMedium,
			CVSS:               6.1,
			Category:           CategoryInjection,
			ExploitComplexity:  ComplexityLow,
			Prerequisites:      []string{"web_access", "user_interaction"},
			Capabilities:       []string{"session_hijacking", "credential_theft"},
			Outputs:            []string{"session_tokens", "user_data"},
			ChainPotential:     0.6,
			ExploitReliability: 0.8,
			DetectionRisk:      0.4,
			Metadata:           make(map[string]interface{}),
		},
	}
}

// generateNetworkVulnerabilities generates network infrastructure vulnerabilities
func (vde *VulnerabilityDiscoveryEngine) generateNetworkVulnerabilities() []*ChainableVulnerability {
	return []*ChainableVulnerability{
		{
			ID:                 uuid.New().String(),
			CVE:                "CVE-2023-9999",
			Name:               "Buffer Overflow",
			Description:        "Buffer overflow in network service",
			Severity:           SeverityCritical,
			CVSS:               9.8,
			Category:           CategoryInputValidation,
			ExploitComplexity:  ComplexityMedium,
			Prerequisites:      []string{"network_access", "service_running"},
			Capabilities:       []string{"code_execution", "privilege_escalation"},
			Outputs:            []string{"system_access", "elevated_privileges"},
			ChainPotential:     0.9,
			ExploitReliability: 0.7,
			DetectionRisk:      0.5,
			Metadata:           make(map[string]interface{}),
		},
	}
}

// generateCloudVulnerabilities generates cloud service vulnerabilities
func (vde *VulnerabilityDiscoveryEngine) generateCloudVulnerabilities() []*ChainableVulnerability {
	return []*ChainableVulnerability{
		{
			ID:                 uuid.New().String(),
			CVE:                "CVE-2023-7777",
			Name:               "IAM Misconfiguration",
			Description:        "Overprivileged IAM role configuration",
			Severity:           SeverityHigh,
			CVSS:               7.5,
			Category:           CategoryConfiguration,
			ExploitComplexity:  ComplexityLow,
			Prerequisites:      []string{"cloud_access", "valid_credentials"},
			Capabilities:       []string{"privilege_escalation", "resource_access"},
			Outputs:            []string{"elevated_permissions", "cloud_resources"},
			ChainPotential:     0.8,
			ExploitReliability: 0.9,
			DetectionRisk:      0.2,
			Metadata:           make(map[string]interface{}),
		},
	}
}

// generateGenericVulnerabilities generates generic vulnerabilities
func (vde *VulnerabilityDiscoveryEngine) generateGenericVulnerabilities() []*ChainableVulnerability {
	return []*ChainableVulnerability{
		{
			ID:                 uuid.New().String(),
			CVE:                "CVE-2023-0000",
			Name:               "Authentication Bypass",
			Description:        "Authentication bypass vulnerability",
			Severity:           SeverityHigh,
			CVSS:               8.0,
			Category:           CategoryAuthentication,
			ExploitComplexity:  ComplexityMedium,
			Prerequisites:      []string{"network_access"},
			Capabilities:       []string{"authentication_bypass"},
			Outputs:            []string{"unauthorized_access"},
			ChainPotential:     0.7,
			ExploitReliability: 0.8,
			DetectionRisk:      0.4,
			Metadata:           make(map[string]interface{}),
		},
	}
}

// ChainAnalyzer analyzes vulnerability chainability
type ChainAnalyzer struct {
	config *VulnerabilityChainConfig
	logger *logger.Logger
}

// NewChainAnalyzer creates a new chain analyzer
func NewChainAnalyzer(config *VulnerabilityChainConfig, logger *logger.Logger) *ChainAnalyzer {
	return &ChainAnalyzer{
		config: config,
		logger: logger,
	}
}

// AnalyzeChainability analyzes the chainability of vulnerabilities
func (ca *ChainAnalyzer) AnalyzeChainability(ctx context.Context, vulnerabilities []*ChainableVulnerability, target *ChainTarget) ([]*ChainableVulnerability, error) {
	var chainableVulns []*ChainableVulnerability

	for _, vuln := range vulnerabilities {
		// Calculate chain potential based on various factors
		chainPotential := ca.calculateChainPotential(vuln, target)
		vuln.ChainPotential = chainPotential

		// Only include vulnerabilities with sufficient chain potential
		if chainPotential >= 0.3 {
			chainableVulns = append(chainableVulns, vuln)
		}
	}

	ca.logger.Info("Chainability analysis completed",
		"total_vulnerabilities", len(vulnerabilities),
		"chainable_vulnerabilities", len(chainableVulns))

	return chainableVulns, nil
}

// calculateChainPotential calculates the chain potential of a vulnerability
func (ca *ChainAnalyzer) calculateChainPotential(vuln *ChainableVulnerability, target *ChainTarget) float64 {
	potential := 0.0

	// Base potential from CVSS score
	potential += vuln.CVSS / 10.0 * 0.3

	// Adjust for exploit complexity
	switch vuln.ExploitComplexity {
	case ComplexityLow:
		potential += 0.3
	case ComplexityMedium:
		potential += 0.2
	case ComplexityHigh:
		potential += 0.1
	}

	// Adjust for capabilities
	potential += float64(len(vuln.Capabilities)) * 0.1

	// Adjust for outputs
	potential += float64(len(vuln.Outputs)) * 0.1

	// Cap at 1.0
	if potential > 1.0 {
		potential = 1.0
	}

	return potential
}

// AttackPathOptimizer optimizes attack paths
type AttackPathOptimizer struct {
	config *VulnerabilityChainConfig
	logger *logger.Logger
}

// NewAttackPathOptimizer creates a new attack path optimizer
func NewAttackPathOptimizer(config *VulnerabilityChainConfig, logger *logger.Logger) *AttackPathOptimizer {
	return &AttackPathOptimizer{
		config: config,
		logger: logger,
	}
}

// GenerateOptimalPaths generates optimal attack paths
func (apo *AttackPathOptimizer) GenerateOptimalPaths(ctx context.Context, vulnerabilities []*ChainableVulnerability, target *ChainTarget, objectives []string) ([]*AttackPath, error) {
	var paths []*AttackPath

	// Generate different path strategies
	paths = append(paths, apo.generateSequentialPaths(vulnerabilities, target)...)
	paths = append(paths, apo.generateParallelPaths(vulnerabilities, target)...)
	paths = append(paths, apo.generateOptimizedPaths(vulnerabilities, target, objectives)...)

	// Filter and rank paths
	filteredPaths := apo.filterViablePaths(paths, target)
	rankedPaths := apo.rankPaths(filteredPaths)

	apo.logger.Info("Attack paths generated",
		"total_paths", len(paths),
		"viable_paths", len(filteredPaths),
		"ranked_paths", len(rankedPaths))

	return rankedPaths, nil
}

// generateSequentialPaths generates sequential attack paths
func (apo *AttackPathOptimizer) generateSequentialPaths(vulnerabilities []*ChainableVulnerability, target *ChainTarget) []*AttackPath {
	var paths []*AttackPath

	// Create simple sequential paths
	for i := 0; i < len(vulnerabilities) && i < apo.config.MaxChainLength; i++ {
		path := &AttackPath{
			ID:              uuid.New().String(),
			Name:            fmt.Sprintf("Sequential-Path-%d", i+1),
			Vulnerabilities: vulnerabilities[i:min(i+3, len(vulnerabilities))],
			Complexity:      0.5,
			Reliability:     0.7,
			Impact:          0.6,
			Risk:            0.4,
			Stealth:         0.6,
			Duration:        time.Hour,
			Metadata:        make(map[string]interface{}),
		}
		paths = append(paths, path)
	}

	return paths
}

// generateParallelPaths generates parallel attack paths
func (apo *AttackPathOptimizer) generateParallelPaths(vulnerabilities []*ChainableVulnerability, target *ChainTarget) []*AttackPath {
	var paths []*AttackPath

	// Create parallel paths for high-impact vulnerabilities
	highImpactVulns := apo.filterHighImpactVulnerabilities(vulnerabilities)

	if len(highImpactVulns) >= 2 {
		path := &AttackPath{
			ID:              uuid.New().String(),
			Name:            "Parallel-High-Impact",
			Vulnerabilities: highImpactVulns[:min(2, len(highImpactVulns))],
			Complexity:      0.7,
			Reliability:     0.8,
			Impact:          0.9,
			Risk:            0.6,
			Stealth:         0.4,
			Duration:        45 * time.Minute,
			Metadata:        make(map[string]interface{}),
		}
		paths = append(paths, path)
	}

	return paths
}

// generateOptimizedPaths generates optimized paths based on objectives
func (apo *AttackPathOptimizer) generateOptimizedPaths(vulnerabilities []*ChainableVulnerability, target *ChainTarget, objectives []string) []*AttackPath {
	var paths []*AttackPath

	// Generate paths optimized for specific objectives
	for _, objective := range objectives {
		optimizedVulns := apo.selectVulnerabilitiesForObjective(vulnerabilities, objective)
		if len(optimizedVulns) > 0 {
			path := &AttackPath{
				ID:              uuid.New().String(),
				Name:            fmt.Sprintf("Optimized-%s", objective),
				Vulnerabilities: optimizedVulns,
				Complexity:      0.6,
				Reliability:     0.8,
				Impact:          0.8,
				Risk:            0.3,
				Stealth:         0.7,
				Duration:        90 * time.Minute,
				Metadata:        map[string]interface{}{"objective": objective},
			}
			paths = append(paths, path)
		}
	}

	return paths
}

// filterHighImpactVulnerabilities filters high-impact vulnerabilities
func (apo *AttackPathOptimizer) filterHighImpactVulnerabilities(vulnerabilities []*ChainableVulnerability) []*ChainableVulnerability {
	var highImpact []*ChainableVulnerability

	for _, vuln := range vulnerabilities {
		if vuln.CVSS >= 7.0 || vuln.Severity == SeverityCritical || vuln.Severity == SeverityHigh {
			highImpact = append(highImpact, vuln)
		}
	}

	return highImpact
}

// selectVulnerabilitiesForObjective selects vulnerabilities for a specific objective
func (apo *AttackPathOptimizer) selectVulnerabilitiesForObjective(vulnerabilities []*ChainableVulnerability, objective string) []*ChainableVulnerability {
	var selected []*ChainableVulnerability

	objectiveMap := map[string][]VulnerabilityCategory{
		"data_exfiltration":    {CategoryInjection, CategoryInformationDisclosure},
		"privilege_escalation": {CategoryAuthentication, CategoryAuthorization},
		"persistence":          {CategoryConfiguration, CategoryBusinessLogic},
		"lateral_movement":     {CategoryAuthentication, CategoryCryptography},
	}

	if categories, exists := objectiveMap[objective]; exists {
		for _, vuln := range vulnerabilities {
			for _, category := range categories {
				if vuln.Category == category {
					selected = append(selected, vuln)
					break
				}
			}
		}
	}

	return selected
}

// filterViablePaths filters viable attack paths
func (apo *AttackPathOptimizer) filterViablePaths(paths []*AttackPath, target *ChainTarget) []*AttackPath {
	var viable []*AttackPath

	for _, path := range paths {
		if apo.isPathViable(path, target) {
			viable = append(viable, path)
		}
	}

	return viable
}

// isPathViable checks if a path is viable
func (apo *AttackPathOptimizer) isPathViable(path *AttackPath, target *ChainTarget) bool {
	// Check if path meets minimum requirements
	if path.Reliability < 0.3 {
		return false
	}

	if path.Impact < apo.config.MinImpactThreshold {
		return false
	}

	if path.Risk > apo.config.MaxRiskThreshold {
		return false
	}

	return true
}

// rankPaths ranks attack paths by score
func (apo *AttackPathOptimizer) rankPaths(paths []*AttackPath) []*AttackPath {
	// Simple ranking by impact * reliability
	for _, path := range paths {
		path.Metadata["score"] = path.Impact * path.Reliability
	}

	// Sort by score
	for i := 0; i < len(paths)-1; i++ {
		for j := i + 1; j < len(paths); j++ {
			score1 := paths[i].Metadata["score"].(float64)
			score2 := paths[j].Metadata["score"].(float64)
			if score2 > score1 {
				paths[i], paths[j] = paths[j], paths[i]
			}
		}
	}

	return paths
}

// Helper function
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
