package usecase

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"regexp"
	"time"

	"github.com/google/uuid"

	"github.com/dimajoyti/hackai/internal/domain"
	"github.com/dimajoyti/hackai/pkg/logger"
)

// VulnerabilityScannerUseCase implements AI-powered vulnerability scanning
type VulnerabilityScannerUseCase struct {
	repo   domain.SecurityRepository
	logger *logger.Logger
}

// NewVulnerabilityScannerUseCase creates a new vulnerability scanner use case
func NewVulnerabilityScannerUseCase(repo domain.SecurityRepository, log *logger.Logger) *VulnerabilityScannerUseCase {
	return &VulnerabilityScannerUseCase{
		repo:   repo,
		logger: log,
	}
}

// StartScan initiates a new vulnerability scan
func (v *VulnerabilityScannerUseCase) StartScan(ctx context.Context, userID uuid.UUID, target string, scanType domain.ScanType, config domain.ScanConfig) (*domain.VulnerabilityScan, error) {
	// Validate target URL
	if err := v.validateTarget(target, scanType); err != nil {
		return nil, fmt.Errorf("invalid target: %w", err)
	}

	// Create scan record
	scan := &domain.VulnerabilityScan{
		UserID:   userID,
		Target:   target,
		ScanType: scanType,
		Status:   domain.ScanStatusPending,
		Config:   config,
	}

	if err := v.repo.CreateVulnerabilityScan(scan); err != nil {
		return nil, fmt.Errorf("failed to create scan: %w", err)
	}

	// Start scan asynchronously
	go v.executeScan(context.Background(), scan)

	v.logger.WithContext(ctx).WithFields(logger.Fields{
		"scan_id":   scan.ID,
		"user_id":   userID,
		"target":    target,
		"scan_type": scanType,
	}).Info("Vulnerability scan started")

	return scan, nil
}

// executeScan performs the actual vulnerability scanning
func (v *VulnerabilityScannerUseCase) executeScan(ctx context.Context, scan *domain.VulnerabilityScan) {
	// Update scan status to running
	scan.Status = domain.ScanStatusRunning
	scan.Progress = 0
	now := time.Now()
	scan.StartedAt = &now

	if err := v.repo.UpdateVulnerabilityScan(scan); err != nil {
		v.logger.WithError(err).Error("Failed to update scan status")
		return
	}

	defer func() {
		if r := recover(); r != nil {
			v.logger.WithField("panic", r).Error("Scan panicked")
			scan.Status = domain.ScanStatusFailed
			v.repo.UpdateVulnerabilityScan(scan)
		}
	}()

	var vulnerabilities []*domain.Vulnerability
	var err error

	// Execute scan based on type
	switch scan.ScanType {
	case domain.ScanTypeWeb:
		vulnerabilities, err = v.scanWebApplication(ctx, scan)
	case domain.ScanTypeAPI:
		vulnerabilities, err = v.scanAPIEndpoint(ctx, scan)
	case domain.ScanTypeSSL:
		vulnerabilities, err = v.scanSSLConfiguration(ctx, scan)
	case domain.ScanTypeDirectory:
		vulnerabilities, err = v.scanDirectoryTraversal(ctx, scan)
	default:
		err = fmt.Errorf("unsupported scan type: %s", scan.ScanType)
	}

	// Update scan completion
	completedAt := time.Now()
	scan.CompletedAt = &completedAt
	scan.Duration = completedAt.Sub(*scan.StartedAt).Milliseconds()
	scan.Progress = 100

	if err != nil {
		scan.Status = domain.ScanStatusFailed
		v.logger.WithError(err).Error("Scan failed")
	} else {
		scan.Status = domain.ScanStatusCompleted
		scan.TotalVulnerabilities = len(vulnerabilities)

		// Count vulnerabilities by severity
		for _, vuln := range vulnerabilities {
			switch vuln.Severity {
			case domain.SeverityCritical:
				scan.CriticalCount++
			case domain.SeverityHigh:
				scan.HighCount++
			case domain.SeverityMedium:
				scan.MediumCount++
			case domain.SeverityLow:
				scan.LowCount++
			case domain.SeverityInfo:
				scan.InfoCount++
			}
		}

		// Save vulnerabilities
		for _, vuln := range vulnerabilities {
			vuln.ScanID = scan.ID
			if err := v.repo.CreateVulnerability(vuln); err != nil {
				v.logger.WithError(err).Error("Failed to save vulnerability")
			}
		}
	}

	if err := v.repo.UpdateVulnerabilityScan(scan); err != nil {
		v.logger.WithError(err).Error("Failed to update scan completion")
	}

	v.logger.WithFields(logger.Fields{
		"scan_id":         scan.ID,
		"status":          scan.Status,
		"vulnerabilities": scan.TotalVulnerabilities,
		"duration_ms":     scan.Duration,
	}).Info("Vulnerability scan completed")
}

// scanWebApplication performs web application vulnerability scanning
func (v *VulnerabilityScannerUseCase) scanWebApplication(ctx context.Context, scan *domain.VulnerabilityScan) ([]*domain.Vulnerability, error) {
	var vulnerabilities []*domain.Vulnerability

	// Update progress
	scan.Progress = 10
	v.repo.UpdateVulnerabilityScan(scan)

	// Fetch the target page
	resp, err := v.fetchURL(scan.Target)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch target: %w", err)
	}
	defer resp.Body.Close()

	// Update progress
	scan.Progress = 30
	v.repo.UpdateVulnerabilityScan(scan)

	// Read response body
	body := make([]byte, 1024*1024) // 1MB limit
	n, _ := resp.Body.Read(body)
	content := string(body[:n])

	// AI-powered vulnerability detection
	vulns := v.detectVulnerabilities(scan.Target, content, resp.Header)
	vulnerabilities = append(vulnerabilities, vulns...)

	// Update progress
	scan.Progress = 60
	v.repo.UpdateVulnerabilityScan(scan)

	// Check for common web vulnerabilities
	vulns = v.checkCommonWebVulns(scan.Target, content)
	vulnerabilities = append(vulnerabilities, vulns...)

	// Update progress
	scan.Progress = 80
	v.repo.UpdateVulnerabilityScan(scan)

	// Check security headers
	vulns = v.checkSecurityHeaders(scan.Target, resp.Header)
	vulnerabilities = append(vulnerabilities, vulns...)

	return vulnerabilities, nil
}

// scanAPIEndpoint performs API endpoint vulnerability scanning
func (v *VulnerabilityScannerUseCase) scanAPIEndpoint(ctx context.Context, scan *domain.VulnerabilityScan) ([]*domain.Vulnerability, error) {
	var vulnerabilities []*domain.Vulnerability

	// Test various HTTP methods
	methods := []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"}

	for i, method := range methods {
		scan.Progress = int((float64(i) / float64(len(methods))) * 100)
		v.repo.UpdateVulnerabilityScan(scan)

		vulns := v.testHTTPMethod(scan.Target, method)
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

// scanSSLConfiguration performs SSL/TLS configuration scanning
func (v *VulnerabilityScannerUseCase) scanSSLConfiguration(ctx context.Context, scan *domain.VulnerabilityScan) ([]*domain.Vulnerability, error) {
	var vulnerabilities []*domain.Vulnerability

	// Parse URL to get host
	u, err := url.Parse(scan.Target)
	if err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Check SSL certificate
	vulns := v.checkSSLCertificate(u.Host)
	vulnerabilities = append(vulnerabilities, vulns...)

	return vulnerabilities, nil
}

// scanDirectoryTraversal performs directory traversal scanning
func (v *VulnerabilityScannerUseCase) scanDirectoryTraversal(ctx context.Context, scan *domain.VulnerabilityScan) ([]*domain.Vulnerability, error) {
	var vulnerabilities []*domain.Vulnerability

	// Common directory traversal payloads
	payloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"....//....//....//etc/passwd",
		"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
	}

	for i, payload := range payloads {
		scan.Progress = int((float64(i) / float64(len(payloads))) * 100)
		v.repo.UpdateVulnerabilityScan(scan)

		vulns := v.testDirectoryTraversal(scan.Target, payload)
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

// AI-powered vulnerability detection using pattern matching and heuristics
func (v *VulnerabilityScannerUseCase) detectVulnerabilities(target, content string, headers http.Header) []*domain.Vulnerability {
	var vulnerabilities []*domain.Vulnerability

	// SQL Injection patterns
	sqlPatterns := []string{
		`(?i)mysql_fetch_array`,
		`(?i)ORA-\d{5}`,
		`(?i)Microsoft.*ODBC.*SQL Server`,
		`(?i)PostgreSQL.*ERROR`,
		`(?i)Warning.*mysql_`,
		`(?i)valid MySQL result`,
		`(?i)MySqlClient\.`,
	}

	for _, pattern := range sqlPatterns {
		if matched, _ := regexp.MatchString(pattern, content); matched {
			vulnerabilities = append(vulnerabilities, &domain.Vulnerability{
				Type:        domain.VulnTypeSQLInjection,
				Severity:    domain.SeverityCritical,
				Title:       "Potential SQL Injection Vulnerability",
				Description: "SQL error messages detected in response, indicating possible SQL injection vulnerability",
				URL:         target,
				Evidence:    v.extractEvidence(content, pattern),
				Solution:    "Use parameterized queries and input validation",
				References:  []string{"https://owasp.org/www-community/attacks/SQL_Injection"},
			})
		}
	}

	// XSS patterns
	xssPatterns := []string{
		`<script[^>]*>.*?</script>`,
		`javascript:`,
		`on\w+\s*=`,
		`<iframe[^>]*>`,
	}

	for _, pattern := range xssPatterns {
		if matched, _ := regexp.MatchString(pattern, content); matched {
			vulnerabilities = append(vulnerabilities, &domain.Vulnerability{
				Type:        domain.VulnTypeXSS,
				Severity:    domain.SeverityHigh,
				Title:       "Potential Cross-Site Scripting (XSS) Vulnerability",
				Description: "Script tags or JavaScript code detected in response",
				URL:         target,
				Evidence:    v.extractEvidence(content, pattern),
				Solution:    "Implement proper input validation and output encoding",
				References:  []string{"https://owasp.org/www-community/attacks/xss/"},
			})
		}
	}

	return vulnerabilities
}

// checkCommonWebVulns checks for common web vulnerabilities
func (v *VulnerabilityScannerUseCase) checkCommonWebVulns(target, content string) []*domain.Vulnerability {
	var vulnerabilities []*domain.Vulnerability

	// Check for sensitive information disclosure
	sensitivePatterns := map[string]string{
		"password":    `(?i)password\s*[:=]\s*['"]\w+['"]`,
		"api_key":     `(?i)api[_-]?key\s*[:=]\s*['"]\w+['"]`,
		"secret":      `(?i)secret\s*[:=]\s*['"]\w+['"]`,
		"private_key": `-----BEGIN.*PRIVATE KEY-----`,
		"email":       `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`,
	}

	for vulnType, pattern := range sensitivePatterns {
		if matched, _ := regexp.MatchString(pattern, content); matched {
			vulnerabilities = append(vulnerabilities, &domain.Vulnerability{
				Type:        domain.VulnTypeInfoDisclosure,
				Severity:    domain.SeverityMedium,
				Title:       fmt.Sprintf("Sensitive Information Disclosure - %s", vulnType),
				Description: fmt.Sprintf("Sensitive %s information found in response", vulnType),
				URL:         target,
				Evidence:    v.extractEvidence(content, pattern),
				Solution:    "Remove sensitive information from public responses",
				References:  []string{"https://owasp.org/www-community/Improper_Error_Handling"},
			})
		}
	}

	return vulnerabilities
}

// checkSecurityHeaders checks for missing security headers
func (v *VulnerabilityScannerUseCase) checkSecurityHeaders(target string, headers http.Header) []*domain.Vulnerability {
	var vulnerabilities []*domain.Vulnerability

	requiredHeaders := map[string]string{
		"X-Content-Type-Options":    "nosniff",
		"X-Frame-Options":           "DENY or SAMEORIGIN",
		"X-XSS-Protection":          "1; mode=block",
		"Strict-Transport-Security": "max-age=31536000",
		"Content-Security-Policy":   "default-src 'self'",
	}

	for header, description := range requiredHeaders {
		if headers.Get(header) == "" {
			vulnerabilities = append(vulnerabilities, &domain.Vulnerability{
				Type:        domain.VulnTypeMisconfiguration,
				Severity:    domain.SeverityLow,
				Title:       fmt.Sprintf("Missing Security Header: %s", header),
				Description: fmt.Sprintf("The %s header is missing, which could lead to security vulnerabilities", header),
				URL:         target,
				Solution:    fmt.Sprintf("Add the %s header with value: %s", header, description),
				References:  []string{"https://owasp.org/www-project-secure-headers/"},
			})
		}
	}

	return vulnerabilities
}

// Helper methods
func (v *VulnerabilityScannerUseCase) validateTarget(target string, scanType domain.ScanType) error {
	if target == "" {
		return fmt.Errorf("target cannot be empty")
	}

	if scanType == domain.ScanTypeWeb || scanType == domain.ScanTypeAPI {
		if _, err := url.Parse(target); err != nil {
			return fmt.Errorf("invalid URL: %w", err)
		}
	}

	return nil
}

func (v *VulnerabilityScannerUseCase) fetchURL(target string) (*http.Response, error) {
	client := &http.Client{
		Timeout: 30 * time.Second,
	}

	req, err := http.NewRequest("GET", target, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", "HackAI-Scanner/1.0")
	return client.Do(req)
}

func (v *VulnerabilityScannerUseCase) extractEvidence(content, pattern string) string {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return ""
	}

	matches := re.FindStringSubmatch(content)
	if len(matches) > 0 {
		evidence := matches[0]
		if len(evidence) > 200 {
			evidence = evidence[:200] + "..."
		}
		return evidence
	}

	return ""
}

func (v *VulnerabilityScannerUseCase) testHTTPMethod(target, method string) []*domain.Vulnerability {
	// Implementation for testing different HTTP methods
	// This would test for method-based vulnerabilities
	return []*domain.Vulnerability{}
}

func (v *VulnerabilityScannerUseCase) checkSSLCertificate(host string) []*domain.Vulnerability {
	// Implementation for SSL certificate checking
	// This would check for SSL/TLS vulnerabilities
	return []*domain.Vulnerability{}
}

func (v *VulnerabilityScannerUseCase) testDirectoryTraversal(target, payload string) []*domain.Vulnerability {
	// Implementation for directory traversal testing
	// This would test for path traversal vulnerabilities
	return []*domain.Vulnerability{}
}
