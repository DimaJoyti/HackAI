apiVersion: v1
kind: Namespace
metadata:
  name: hackai
  labels:
    name: hackai
    app.kubernetes.io/name: hackai
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/component: platform
    app.kubernetes.io/part-of: hackai-platform
---
# ðŸ”’ SECURITY WARNING: This is a template file!
#
# DO NOT use these hardcoded secrets in production!
#
# For production deployment:
# 1. Use external secret management (AWS Secrets Manager, Azure Key Vault, etc.)
# 2. Use Kubernetes External Secrets Operator
# 3. Use Helm with values files that reference external secrets
# 4. Generate secrets using: kubectl create secret generic hackai-secrets --from-env-file=.env
#
# Example production secret creation:
# kubectl create secret generic hackai-secrets \
#   --from-literal=db-password="$(openssl rand -base64 32)" \
#   --from-literal=redis-password="$(openssl rand -base64 32)" \
#   --from-literal=jwt-secret="$(openssl rand -base64 32)" \
#   --from-literal=ai-api-key="${OPENAI_API_KEY}" \
#   --namespace=hackai

apiVersion: v1
kind: Secret
metadata:
  name: hackai-secrets
  namespace: hackai
  annotations:
    # Use external secret management in production
    external-secrets.io/backend: "vault"
    external-secrets.io/key: "hackai/secrets"
type: Opaque
data:
  # ðŸ”’ TEMPLATE VALUES - REPLACE IN PRODUCTION!
  # Generate real secrets using: echo -n "your-secret" | base64
  db-password: ""          # Set via: kubectl patch secret hackai-secrets -p '{"data":{"db-password":"'$(echo -n "$DB_PASSWORD" | base64)'"}}'
  redis-password: ""       # Set via: kubectl patch secret hackai-secrets -p '{"data":{"redis-password":"'$(echo -n "$REDIS_PASSWORD" | base64)'"}}'
  jwt-secret: ""           # Set via: kubectl patch secret hackai-secrets -p '{"data":{"jwt-secret":"'$(echo -n "$JWT_SECRET" | base64)'"}}'
  ai-api-key: ""           # Set via: kubectl patch secret hackai-secrets -p '{"data":{"ai-api-key":"'$(echo -n "$OPENAI_API_KEY" | base64)'"}}'
  encryption-key: ""       # Set via: kubectl patch secret hackai-secrets -p '{"data":{"encryption-key":"'$(echo -n "$ENCRYPTION_KEY" | base64)'"}}'
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hackai-config
  namespace: hackai
data:
  # Database configuration
  DB_HOST: "postgres"
  DB_PORT: "5432"
  DB_NAME: "hackai"
  DB_USER: "hackai"
  
  # Redis configuration
  REDIS_HOST: "redis"
  REDIS_PORT: "6379"
  
  # Application configuration
  LOG_LEVEL: "info"
  APP_ENV: "production"
  
  # AI configuration
  AI_MODEL_ENDPOINT: "https://api.openai.com/v1"
  AI_MODEL_NAME: "gpt-4"
  MAX_TOKENS: "4000"
  
  # Security configuration
  CORS_ORIGINS: "https://hackai.com,https://app.hackai.com"
  JWT_EXPIRY: "24h"
  BCRYPT_COST: "12"
  
  # Monitoring configuration
  JAEGER_ENDPOINT: "http://jaeger:14268/api/traces"
  PROMETHEUS_ENDPOINT: "http://prometheus:9090"
  
  # External services
  SMTP_HOST: "smtp.gmail.com"
  SMTP_PORT: "587"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: hackai-service-account
  namespace: hackai
  labels:
    app.kubernetes.io/name: hackai
    app.kubernetes.io/component: service-account
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: hackai
  name: hackai-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: hackai-role-binding
  namespace: hackai
subjects:
- kind: ServiceAccount
  name: hackai-service-account
  namespace: hackai
roleRef:
  kind: Role
  name: hackai-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: hackai-network-policy
  namespace: hackai
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  - to: {}
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
  - to: {}
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80
