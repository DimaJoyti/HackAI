name: Multi-Cloud Infrastructure Deployment

on:
  push:
    branches: [main, develop]
    paths:
      - 'infrastructure/**'
      - 'deployments/**'
      - 'serverless/**'
  pull_request:
    branches: [main]
    paths:
      - 'infrastructure/**'
      - 'deployments/**'
      - 'serverless/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      cloud_providers:
        description: 'Cloud providers to deploy (comma-separated)'
        required: true
        default: 'aws,gcp,azure'
        type: string
      deploy_serverless:
        description: 'Deploy serverless functions'
        required: false
        default: true
        type: boolean

env:
  TF_VERSION: '1.6.0'
  KUBECTL_VERSION: '1.28.0'
  HELM_VERSION: '3.13.0'
  TERRAFORM_WORKSPACE: ${{ github.event.inputs.environment || 'development' }}

jobs:
  # Security and validation checks
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Checkov static analysis
        uses: bridgecrewio/checkov-action@master
        with:
          directory: infrastructure/
          framework: terraform
          output_format: sarif
          output_file_path: checkov-results.sarif

  # Terraform validation and planning
  terraform-validate:
    name: Terraform Validate
    runs-on: ubuntu-latest
    needs: security-scan
    strategy:
      matrix:
        cloud: ['aws', 'gcp', 'azure']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive infrastructure/

      - name: Terraform Init - Multi-Cloud
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform init -backend=false

      - name: Terraform Validate - Multi-Cloud
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform validate

      - name: Terraform Init - ${{ matrix.cloud }}
        run: |
          cd infrastructure/terraform/multi-cloud/modules/${{ matrix.cloud }}
          terraform init -backend=false

      - name: Terraform Validate - ${{ matrix.cloud }}
        run: |
          cd infrastructure/terraform/multi-cloud/modules/${{ matrix.cloud }}
          terraform validate

  # Build and test serverless functions
  build-serverless:
    name: Build Serverless Functions
    runs-on: ubuntu-latest
    if: github.event.inputs.deploy_serverless == 'true' || github.event.inputs.deploy_serverless == ''
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Build AWS Lambda functions
        run: |
          cd serverless/aws-lambda
          for func in */; do
            echo "Building $func"
            cd "$func"
            GOOS=linux GOARCH=amd64 go build -o main main.go
            zip "../${func%/}.zip" main
            cd ..
          done

      - name: Upload Lambda artifacts
        uses: actions/upload-artifact@v3
        with:
          name: lambda-functions
          path: serverless/aws-lambda/*.zip

  # Infrastructure deployment
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [terraform-validate, security-scan]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment || 'development' }}
    strategy:
      matrix:
        cloud: ['aws', 'gcp', 'azure']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        if: matrix.cloud == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Configure GCP credentials
        if: matrix.cloud == 'gcp'
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure Azure credentials
        if: matrix.cloud == 'azure'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform init

      - name: Terraform Workspace
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform workspace select ${{ env.TERRAFORM_WORKSPACE }} || terraform workspace new ${{ env.TERRAFORM_WORKSPACE }}

      - name: Terraform Plan
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform plan \
            -var-file="environments/${{ env.TERRAFORM_WORKSPACE }}.tfvars" \
            -var="enable_${{ matrix.cloud }}=true" \
            -out=tfplan-${{ matrix.cloud }}

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform apply -auto-approve tfplan-${{ matrix.cloud }}

      - name: Save Terraform outputs
        run: |
          cd infrastructure/terraform/multi-cloud
          terraform output -json > outputs-${{ matrix.cloud }}.json

      - name: Upload Terraform outputs
        uses: actions/upload-artifact@v3
        with:
          name: terraform-outputs-${{ matrix.cloud }}
          path: infrastructure/terraform/multi-cloud/outputs-${{ matrix.cloud }}.json

  # Deploy serverless functions
  deploy-serverless:
    name: Deploy Serverless Functions
    runs-on: ubuntu-latest
    needs: [build-serverless, deploy-infrastructure]
    if: github.event.inputs.deploy_serverless == 'true' || github.event.inputs.deploy_serverless == ''
    environment: ${{ github.event.inputs.environment || 'development' }}
    strategy:
      matrix:
        cloud: ['aws', 'gcp', 'azure']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Lambda artifacts
        if: matrix.cloud == 'aws'
        uses: actions/download-artifact@v3
        with:
          name: lambda-functions
          path: serverless/aws-lambda/

      - name: Configure AWS credentials
        if: matrix.cloud == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Deploy AWS Lambda functions
        if: matrix.cloud == 'aws'
        run: |
          cd serverless/aws-lambda
          for zip_file in *.zip; do
            function_name="${zip_file%.zip}"
            echo "Deploying $function_name"
            
            # Check if function exists
            if aws lambda get-function --function-name "hackai-${{ env.TERRAFORM_WORKSPACE }}-$function_name" 2>/dev/null; then
              # Update existing function
              aws lambda update-function-code \
                --function-name "hackai-${{ env.TERRAFORM_WORKSPACE }}-$function_name" \
                --zip-file "fileb://$zip_file"
            else
              echo "Function does not exist, will be created by Terraform"
            fi
          done

      - name: Configure GCP credentials
        if: matrix.cloud == 'gcp'
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Deploy GCP Cloud Functions
        if: matrix.cloud == 'gcp'
        run: |
          echo "Deploying GCP Cloud Functions"
          # GCP Cloud Functions deployment logic here

      - name: Configure Azure credentials
        if: matrix.cloud == 'azure'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy Azure Functions
        if: matrix.cloud == 'azure'
        run: |
          echo "Deploying Azure Functions"
          # Azure Functions deployment logic here

  # Deploy applications to Kubernetes
  deploy-applications:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    environment: ${{ github.event.inputs.environment || 'development' }}
    strategy:
      matrix:
        cloud: ['aws', 'gcp', 'azure']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Download Terraform outputs
        uses: actions/download-artifact@v3
        with:
          name: terraform-outputs-${{ matrix.cloud }}
          path: ./

      - name: Configure kubectl for AWS EKS
        if: matrix.cloud == 'aws'
        run: |
          aws eks update-kubeconfig \
            --region us-west-2 \
            --name $(jq -r '.aws_infrastructure.value.cluster_id' outputs-aws.json) \
            --alias aws-${{ env.TERRAFORM_WORKSPACE }}

      - name: Configure kubectl for GCP GKE
        if: matrix.cloud == 'gcp'
        run: |
          gcloud container clusters get-credentials \
            $(jq -r '.gcp_infrastructure.value.cluster_name' outputs-gcp.json) \
            --region us-central1 \
            --project $(jq -r '.gcp_infrastructure.value.project_id' outputs-gcp.json)

      - name: Configure kubectl for Azure AKS
        if: matrix.cloud == 'azure'
        run: |
          az aks get-credentials \
            --resource-group $(jq -r '.azure_infrastructure.value.resource_group_name' outputs-azure.json) \
            --name $(jq -r '.azure_infrastructure.value.cluster_name' outputs-azure.json) \
            --overwrite-existing

      - name: Deploy with Helm
        run: |
          helm upgrade --install hackai-${{ matrix.cloud }} \
            ./deployments/helm/hackai \
            --namespace hackai-${{ env.TERRAFORM_WORKSPACE }} \
            --create-namespace \
            --set app.environment=${{ env.TERRAFORM_WORKSPACE }} \
            --set global.cloudProvider=${{ matrix.cloud }} \
            --values ./deployments/helm/hackai/values-${{ matrix.cloud }}.yaml \
            --wait --timeout=10m

      - name: Verify deployment
        run: |
          kubectl get pods -n hackai-${{ env.TERRAFORM_WORKSPACE }}
          kubectl get services -n hackai-${{ env.TERRAFORM_WORKSPACE }}

  # Post-deployment validation
  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-applications, deploy-serverless]
    environment: ${{ github.event.inputs.environment || 'development' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run health checks
        run: |
          echo "Running health checks..."
          # Add health check scripts here

      - name: Run integration tests
        run: |
          echo "Running integration tests..."
          # Add integration test scripts here

      - name: Generate deployment report
        run: |
          echo "Generating deployment report..."
          # Generate deployment summary and metrics

  # Cleanup on failure
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-serverless, deploy-applications]
    if: failure() && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Destroy (if needed)
        run: |
          echo "Cleanup logic here"
          # Add cleanup logic for failed deployments

  # Notification
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    if: always()
    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
